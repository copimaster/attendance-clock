using Avalonia;
using Avalonia.Animation;
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Media;
using Avalonia.Styling;
using Avalonia.Threading;
using Avalonia.VisualTree;
using DPUruNet;
using ExCSS;
using MsBox.Avalonia.Enums;
using NAudio.Wave;
using Newtonsoft.Json;
using NLog;
using NLog.Config;
using NLog.Targets;
using ReactiveUI;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Reactive;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using VTA_Clock;
using VTACheckClock.DBAccess;
using VTACheckClock.Helpers;
using VTACheckClock.Models;
using VTACheckClock.Services;
using VTACheckClock.Services.Libs;
using VTACheckClock.Views;
using static VTACheckClock.Services.CommonObjs;
using static VTACheckClock.Views.MessageBox;
using Bitmap = Avalonia.Media.Imaging.Bitmap;
using Cue = Avalonia.Animation.Cue;

namespace VTACheckClock.ViewModels
{
    /*public*/
    class MainWindowViewModel : ViewModelBase
    {
        public string Greeting => "Welcome to Avalonia!"; //Code generated by default

        private readonly WSClient _WSClient = new();
        public string _currentTime = "00:00:00";
        public CommonObjs.RemoteTime? _currentRemoteTime;
        public string _currentLongDate = "";
        public string _networkConStatus = "Sin conexión";
        public string _office = "";
        public string _status = "Servidor Websocket desconectado";
        public string _empName = "";
        public string _empEvent = "Esperando huella...";
        private string? _searchText;
        private bool _IsPusherConnected, _IsNetConnected;
        private int _selectedIndex = 0, _selectedItem = 0, _lastEmployeeEvent = 0;
        private int _foundIndex = -2, _pwdPunchIndex = -2; //-2 Initialized, -1 Not found Index
        private bool _isSyncing = true, _sync = false;
        private Notice? _newNotice;
        private Bitmap? _logoImage;

        private string _noticeTitle = "", _noticeBody = "", _platform = "", _syncError = "";
        private Bitmap? _noticeImage;
        private bool _emptyNotices;
        private readonly DispatcherTimer tmrCachedTime = new();
        private readonly DispatcherTimer tmrClock = new();
        private readonly DispatcherTimer tmrNotices = new();
        private readonly DispatcherTimer tmrSyncRetry = new();
        private readonly DispatcherTimer tmrCheckNetConnection = new();
        private readonly BackgroundWorker bgwLoader = new();

        //private SourceList<Employee> _sourceList = new();
        //private readonly ReadOnlyObservableCollection<Employee> _attsList;
        //public ReadOnlyObservableCollection<Employee> AttsList => _attsList;
        public ObservableCollection<Employee>? AttsList { get; set; } = new();
        public ObservableCollection<Employee> SearchResults { get; } = new();

        public ObservableCollection<EmployeePunch> EmpPunches { get; }
        public ObservableCollection<Notice> Notices { get; }
        public ObservableCollection<FMDItem> FingerPrints { get; }
        public List<PageTransition> PageTransitions { get; } = new List<PageTransition>();
        public ReactiveCommand<Unit, Unit>? PwdPunchCommand { get; }
        public Interaction<PwdPunchViewModel, int> ShowPwdPunchDialog { get; } = new();
        public Interaction<WebsocketLoggerViewModel, bool> ShowLoggerDialog { get; } = new();
        public Interaction<LoginViewModel, bool> ShowLoginDialog { get; } = new();
        public ICommand? LoginCommand { get; }
        public ICommand? LogOutCommand { get; }
        public ICommand? PreviewLoggerCommand { get; }
        public ICommand? SyncEvtCommand { get; }

        public ICommand? TestCommand { get; }

        public ICommand SendEmailCommand { get; }

        //public CheckClockMainViewModel? ClockMain { get; } DEPRECATED AND DELETED FILE: USED ONLY WITH "Content"

        ViewModelBase content = new();

        public Bitmap? LogoImage { 
            get => _logoImage;
            set => this.RaiseAndSetIfChanged(ref _logoImage, value);
        }
        
        //public Task<Bitmap?> LogoImageFromWebSite { get; } = ImageHelper.LoadFromWeb(new Uri("https://upload.wikimedia.org/wikipedia/commons/4/41/NewtonsPrincipia.jpg"));
        
        public string CurrentTime
        {
            get => _currentTime;
            set => this.RaiseAndSetIfChanged(ref _currentTime, value);
        }

        /// <summary>
        /// Esta variable es un modelo que almacena la hora remota en formato DateTime y String.
        /// </summary>
        public RemoteTime? CurrentRemoteTime
        {
            get => _currentRemoteTime;
            set => this.RaiseAndSetIfChanged(ref _currentRemoteTime, value);
        }

        public string CurrentLongDate
        {
            get => _currentLongDate;
            set => this.RaiseAndSetIfChanged(ref _currentLongDate, value);
        }

        public string Status
        {
            get => _status;
            set => this.RaiseAndSetIfChanged(ref _status, value);
        }
        public bool IsPusherConnected
        {
            get => _IsPusherConnected;
            set => this.RaiseAndSetIfChanged(ref _IsPusherConnected, value);
        }

        public string NetworkConStatus
        {
            get => _networkConStatus;
            set => this.RaiseAndSetIfChanged(ref _networkConStatus, value);
        }

        public string Office
        {
            get => _office;
            set => this.RaiseAndSetIfChanged(ref _office, value);
        }

        public bool IsNetConnected
        {
            get => _IsNetConnected;
            set => this.RaiseAndSetIfChanged(ref _IsNetConnected, value);
        }

        public string EmployeeName
        {
            get => _empName;
            set => this.RaiseAndSetIfChanged(ref _empName, value);
        }

        public string EmployeeEvent
        {
            get => _empEvent;
            set => this.RaiseAndSetIfChanged(ref _empEvent, value);
        }

        public int SelectedIndex
        {
            get => _selectedIndex;
            set => this.RaiseAndSetIfChanged(ref _selectedIndex, value);
        }

        public int SelectedItem
        {
            get => _selectedItem;
            set => this.RaiseAndSetIfChanged(ref _selectedItem, value);
        }

        public int LastEmployeeEventItem
        {
            get => _lastEmployeeEvent;
            set => this.RaiseAndSetIfChanged(ref _lastEmployeeEvent, value);
        }

        public bool NoticeCollectionEmpty
        {
            get => _emptyNotices;
            set => this.RaiseAndSetIfChanged(ref _emptyNotices, value);
        }

        public string NoticeTitle
        {
            get => _noticeTitle;
            set => this.RaiseAndSetIfChanged(ref _noticeTitle, value);
        }

        public string NoticeBody
        {
            get => _noticeBody;
            set => this.RaiseAndSetIfChanged(ref _noticeBody, value);
        }

        public Bitmap? NoticeImage
        {
            get => _noticeImage;
            private set => this.RaiseAndSetIfChanged(ref _noticeImage, value);
        }

        public string? SearchText
        {
            get => _searchText;
            set => this.RaiseAndSetIfChanged(ref _searchText, value);
        }

        private PageTransition? _SelectedTransition;

        /// <summary>
        /// Gets or sets the transition to play
        /// </summary>
        public PageTransition? SelectedTransition
        {
            get { return _SelectedTransition; }
            set { this.RaiseAndSetIfChanged(ref _SelectedTransition, value); }
        }

        private int _Duration = 500;

        /// <summary>
        /// Gets or Sets the duration
        /// </summary>
        public int Duration
        {
            get { return _Duration; }
            set
            {
                this.RaiseAndSetIfChanged(ref _Duration, value);
                SetupTransitions();
            }
        }

        public int FoundIndex
        {
            get => _foundIndex;
            set => this.RaiseAndSetIfChanged(ref _foundIndex, value);
        }

        public int PwdPunchIndex
        {
            get => _pwdPunchIndex;
            set => this.RaiseAndSetIfChanged(ref _pwdPunchIndex, value);
        }

        public bool IsSyncing
        {
            get => _isSyncing;
            set => this.RaiseAndSetIfChanged(ref _isSyncing, value);
        }

        public bool ShowLoader
        {
            get => _sync;
            set => this.RaiseAndSetIfChanged(ref _sync, value);
        }

        public Notice? NewNotice
        {
            get => _newNotice;
            set => this.RaiseAndSetIfChanged(ref _newNotice, value);
        }

        public string PlatformInfo {
            get => _platform;
            set => this.RaiseAndSetIfChanged(ref _platform, value);
        }

        public string SyncError
        {
            get => _syncError;
            set => this.RaiseAndSetIfChanged(ref _syncError, value);
        }

        private EmailSenderHandler EmailSender = new();

        public MainWindowViewModel(string? text = null)
        {
            //Content = ClockMain = new CheckClockMainViewModel(FoundIndex);
            AttsList = new ObservableCollection<Employee>();
            EmpPunches = new ObservableCollection<EmployeePunch>();
            Notices = new ObservableCollection<Notice>();
            FingerPrints = new ObservableCollection<FMDItem>();

            AttsList.CollectionChanged += AttsList_CollectionChanged;
            AddNLogConfiguration();
            Dispatcher.UIThread.InvokeAsync(async() => {
                await FormLoad();
                await FormShown();
            });

            this.WhenAnyValue(x => x.Notices.Count).Subscribe(x => NoticeCollectionEmpty = x == 0);

            //_sourceList.Connect()
            //.Sort(SortExpressionComparer<Employee>.Ascending(t => t.Index))
            //.Bind(out _attsList)
            //.Subscribe();

            this.WhenAnyValue(x => x.PwdPunchIndex).Where(y => y != -2).Subscribe(PunchIt!);
            //this.WhenAnyValue(x => x.SelectedIndex).Subscribe(ShowEventsByEmployee!);

            LoginCommand = ReactiveCommand.CreateFromTask(InvokeLogin);
            LogOutCommand = ReactiveCommand.CreateFromTask(async() => {
                var _result = await ShowPrompt("¿Salir?", "¿Confirma que desea salir de la aplicación?");
                if (_result == ButtonResult.Yes) {
                    await InvokeManualSync();
                    GlobalVars.ForceExit = true;
                    await new MainWindow().LogOut(true);
                }
            });

            PreviewLoggerCommand = ReactiveCommand.CreateFromTask(async () => {
                var frmPassPunc = new WebsocketLoggerViewModel();
                var result = await ShowLoggerDialog.Handle(frmPassPunc);
            });
            //SyncEvtCommand = ReactiveCommand.CreateFromTask(InvokeManualSync(false));
            this.WhenAnyValue(x => x.ShowLoader).Where(y => y).Subscribe(InvokeManualSyncEvt!);
            this.WhenAnyValue(x => x.NewNotice).Where(y => y != null).Subscribe(AddNewNotice!);
            this.WhenAnyValue(x => x.SearchText).Throttle(TimeSpan.FromMilliseconds(500)).ObserveOn(RxApp.MainThreadScheduler).Subscribe(DoSearch!);

            NetworkChange.NetworkAvailabilityChanged += OnNetworkAvailabilityChanged;

            SendEmailCommand = ReactiveCommand.CreateFromTask(async () => await SendEmployeesWithNoCheckInOut());
            _WSClient.PunchReceived += WSClient_MessageReceived;
        }

        private void AttsList_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            try {
                if(e.Action == NotifyCollectionChangedAction.Add) {
                    foreach (Employee newItem in e.NewItems)
                    {
                        SearchResults.Add(newItem);
                    }
                }
                else if (e.Action == NotifyCollectionChangedAction.Reset) {
                    SearchResults.Clear();
                }
            }
            catch (Exception ex) {
                Debug.WriteLine(ex.ToString());
            }
        }

        /// <summary>
        /// Registra un manejador de eventos para el evento de registro de NLog
        /// </summary>
        private static void AddNLogConfiguration()
        {
            // Registrar un manejador de eventos para el evento de registro de NLog
            var config = new LoggingConfiguration();
            //var memoryTarget = new MemoryTarget("logViewer");
            //config.AddTarget(memoryTarget);

            // Configurar la salida del Logger
            var fileTarget = new FileTarget("logfile")
            {
                FileName = "${basedir}/logs/AppLog.txt",
                //Layout = "${longdate} ${level:uppercase=true} ${message} ${exception:format=ToString}${newline}",
                ArchiveAboveSize = 10240,
                AutoFlush = true,
                KeepFileOpen = false, //(false) Permite que el archivo se cierre después de cada escritura
                ArchiveFileName = "${basedir}/logs/archive/AppLog.{####}.txt",
                ArchiveEvery = FileArchivePeriod.Day,
                ArchiveNumbering = ArchiveNumberingMode.DateAndSequence, //Sequence
                MaxArchiveFiles = 20,
                Encoding = System.Text.Encoding.UTF8
            };

            //config.AddTarget(fileTarget);
            config.AddRule(LogLevel.Trace, LogLevel.Fatal, fileTarget);
            config.AddRule(new LoggingRule("app_logger", LogLevel.Info, fileTarget));
            //config.LoggingRules.Add(new LoggingRule("app_logger", LogLevel.Debug, memoryTarget));

            // Asignar la configuración al LogManager
            LogManager.Configuration = config;
            //LogManager.ReconfigExistingLoggers();
        }

        public ViewModelBase Content
        {
            get => content;
            private set => this.RaiseAndSetIfChanged(ref content, value);
        }

        /// <summary>
        /// Detectar la plataforma y configurar la detección de cambios en la hora del sistema
        /// </summary>
        private void GetPlatform()
        {
            /*
            var runtimeInfo = AvaloniaLocator.Current.GetService<IRuntimePlatform>()?.GetRuntimeInfo();
            if (runtimeInfo is { } info) {
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Create("BROWSER"))) {
                    if (info.IsDesktop) {
                      PlatformInfo = "Platform: Desktop (browser)";
                    } else if (info.IsMobile) {
                      PlatformInfo = "Platform: Mobile (browser)";
                    } else {
                      PlatformInfo = "Platform: Unknown (browser) - please report";
                    }
                } else {
                    if (info.IsDesktop) {
                        PlatformInfo = "Platform: Desktop (native)";
                    } else if (info.IsMobile) {
                        PlatformInfo = "Platform: Mobile (native)";
                    } else {
                        PlatformInfo = "Platform: Unknown (native) - please report";
                    }
                }
            }

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                SystemEvents.TimeChanged += (sender, e) => {
                    //TimeZoneInfo.ClearCachedData();
                    log.Info("Se ha detectado un cambio de hora en el servidor local.");
                };
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                // Configurar la detección de cambios en la hora del sistema en Linux (utilizando libnotify, por ejemplo)

            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                // Configurar la detección de cambios en la hora del sistema en macOS
            }*/
        }

        private void SetupTransitions()
        {
            if (PageTransitions.Count == 0)
            {
                PageTransitions.AddRange(new[] {
                    new PageTransition("None"),
                    new PageTransition("CrossFade"),
                    new PageTransition("Slide horizontally"),
                    new PageTransition("Slide vertically"),
                    new PageTransition("Composite"),
                    new PageTransition("Custom")
                });
            }

            //The "CrossFade" fades out the current view and fades in the new view by animating the opacity.
            PageTransitions[1].Transition = new CrossFade(TimeSpan.FromMilliseconds(Duration));
            // The "PageSlide" slides the content either horizontally or vertically.
            // You can specify the slide axis via the Orientation-property. The default value is Horizontal.
            PageTransitions[2].Transition = new PageSlide(TimeSpan.FromMilliseconds(Duration), PageSlide.SlideAxis.Horizontal);
            PageTransitions[3].Transition = new PageSlide(TimeSpan.FromMilliseconds(Duration), PageSlide.SlideAxis.Vertical);
            //The "CompositePageTransition" is used create a combined transition of several different transitions.
            var compositeTransition = new CompositePageTransition();
            compositeTransition.PageTransitions.Add(PageTransitions[1].Transition!);
            compositeTransition.PageTransitions.Add(PageTransitions[2].Transition!);
            compositeTransition.PageTransitions.Add(PageTransitions[3].Transition!);
            PageTransitions[4].Transition = compositeTransition;

            PageTransitions[5].Transition = new CustomTransition(TimeSpan.FromMilliseconds(Duration));

            _SelectedTransition = PageTransitions[1];
        }

        private bool IsInternetConnected;
        private void OnNetworkAvailabilityChanged(object? sender, NetworkAvailabilityEventArgs e)
        {
            try {
                // Actualizar el estado de conexión a internet
                IsInternetConnected = e.IsAvailable;

                Dispatcher.UIThread.InvokeAsync(async () => {
                    if (IsInternetConnected) {
                        // Esperar durante 5 segundos antes de sincronizar datos
                        await Task.Delay(TimeSpan.FromSeconds(5));

                        // Verificar si la conexión sigue activa antes de sincronizar
                        if (IsInternetConnected) {
                            log.Warn("El equipo se conectó de nuevo a Internet.");
                       
                            await SyncWithLoader();
                            await _WSClient.ReloadConnection();
                        } else {
                            log.Warn("La conexión a Internet se perdió nuevamente antes de sincronizar.");
                        }
                    } else { 
                        log.Warn("El equipo se desconectó de Internet.");
                    }
                });
            } catch(Exception ex) {
                IsInternetConnected = false;
                log.Warn("OnNetworkAvailabilityChangedError: " + ex.Message);
            }
        }

        private bool IsDuplicated(Employee? item) => AttsList != null && AttsList.Any(e => e.EventTime == item.EventTime && e.EventType == item.EventType && e.EmpID == item.EmpID);

        /// <summary>
        /// Escucha los cambios del evento 'PunchReceived' y recibe la información enviada desde el servidor al cliente. 
        /// Finalmente, actualiza el listado de asistencias en todos los clientes subscritos al canal y agrega el registro en cache y memoria de la Aplicación.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="message"></param>
        private async void WSClient_MessageReceived(object? sender, string message)
        {
            try {
                Employee? EmpData = Employee.FromJson(message);

                // Verifica si estás en el hilo de la UI
                if (Dispatcher.UIThread.CheckAccess())
                {
                    // Si ya estás en el hilo de la UI, simplemente agrega el elemento
                    if (!IsDuplicated(EmpData)) {
                        AttsList.Add(EmpData!);
                        await AddEmployee(message);
                    }
                }
                else
                {
                    // Si no estás en el hilo de la UI, usa Dispatcher para invocar la operación en el hilo de la UI
                    if (!IsDuplicated(EmpData)) {
                        await Dispatcher.UIThread.InvokeAsync(() => AttsList.Add(EmpData!));
                        await AddEmployee(message);
                    }
                }

                SelectedIndex = AttsList.Count - 1;
            }
            catch (Exception ex) {
                log.Warn("Error al procesar el Evento de Websocket recibido: " + ex.Message);
            }
        }

        public static int GetIndexByName(string[] array, string? name)
        {
            var index = Array.IndexOf(array, name);
            return (index != -1) ? index : 0;
        }
        
        /// <summary>
        /// Agrega un registro de Evento recibido por medio de un Canal de Websocket, en memoria y cache para sincronizar diferentes dispositivos conectados a un canal de WebSocket.
        /// </summary>
        /// <param name="PunchRecord"></param>
        /// <returns></returns>
        public async Task<bool> AddEmployee(string message)
        {
            PunchRecord? PunchRecord = JsonConvert.DeserializeObject<PunchRecord>(message);

            PunchLine new_punch = new() {
                Punchemp = PunchRecord.IdEmployee,
                Punchevent = PunchRecord.IdEvent,
                Punchtime = PunchRecord?.EventTime != null ? DateTime.Parse(PunchRecord.EventTime) : DateTime.MinValue,
                Punchinternaltime = PunchRecord?.InternalEventTime != null ? DateTime.Parse(PunchRecord.InternalEventTime) : DateTime.MinValue
            };

            // Agrega el registro en la lista de la "memoria"
            emp_punches.Rows.Add(new_punch.Punchemp.ToString(), new_punch.Punchevent.ToString(), PunchRecord.EventTime, PunchRecord.InternalEventTime);

            // Agrega el registro en el archivo de Cache
            GlobalVars.AppCache.StorePunch(new_punch);

            return await Task.FromResult(true);
        }

        /// <summary>
        /// Muestra una ventana emergente, el cual pregunta si quiere cerrar sesión, únicamente cuando se presiona el botón de "Salir".
        /// </summary>
        /// <returns></returns>
        private async Task InvokeLogin()
        {
             if (GlobalVars.BeOffline) {
                 await ShowMessage("Aplicación sin conexión", "La aplicación se encuentra actualmente en modo «Fuera de línea». No es posible reconfigurarla hasta que exista una conexión activa a Internet.", -1, 140);
             } else {
                var frmPassPunc = new LoginViewModel();
                await ShowLoginDialog.Handle(frmPassPunc);
             }
        }


        private async void DoSearch(string s)
        {
            SearchResults.Clear();

            if (!string.IsNullOrWhiteSpace(s) && AttsList != null)
            {
                var filteredEntries = await Task.Run(() => {
                    return AttsList.Where(entry => entry.FullName.ToLower().Contains(s.ToLower(), StringComparison.OrdinalIgnoreCase)).ToList();
                });

                foreach (var entry in filteredEntries)
                {
                    SearchResults.Add(entry);
                }
            } else if(AttsList != null) {
                foreach (var entry in AttsList)
                {
                    SearchResults.Add(entry);
                }
            }

            SelectedIndex = SearchResults.Count - 1;
        }

        #region Inicialización
        private int IDThreshold = 0; //CommonProcs.ParamInt(7) * 1 / CommonProcs.ParamInt(8)
        private static int curr_not = 0;
        private bool forceexit = false;
        private DataTable? emp_punches;
        private readonly NoticeData def_not = new() { nottit = "", notmsg = "No se encontró ningún aviso para esta ubicación o no se pudieron cargar." };
        private List<Fmd>? las_fmds;
        private static List<NoticeData>? notices;
        private List<FMDItem>? fmd_collection;
        public int elid_idx = -1;
        public MainSettings? m_settings;
        private readonly Logger log = LogManager.GetLogger("app_logger");
        private static readonly string[] PunchSounds = { "", "Entry", "Exit", "Unknown", "Error" };
        private WaveOutEvent? waveOutEvent;
        private bool ScheduleTriggered = false;
        private static DateTime LastSyncDate = DateTime.MinValue;
        private static bool RetryingSync = false;

        /// <summary>
        /// Evento LOAD del formulario.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private async Task FormLoad()
        {
            await FormInit();
            if (!GlobalVars.NoFPReader) StartReader();
            await SetClock();
            m_settings = RegAccess.GetMainSettings() ?? new MainSettings();
            await _WSClient.Connect();
        }

        /// <summary>
        /// Inicializa el entorno del formulario.
        /// </summary>
        private async Task FormInit()
        {
            GetPlatform();
            SetupTransitions();
            ConfigTimers();
            ToggleTimers(false);
            await UpdateInfoLabels(0);
            MakeClockSession();
            GetOffice();
            SetLogo();
        }

        /// <summary>
        /// Invoca la sincronización de inicio.
        /// </summary>
        private async Task StarterSync()
        {
            GlobalVars.StartingUp = true;
            await SyncWithLoader();
            GlobalVars.StartingUp = false;
        }

        /// <summary>
        /// Crea el objeto SessionData que utilizará la interfaz del Reloj Checador.
        /// </summary>
        private static void MakeClockSession()
        {
            GlobalVars.clockSession = new SessionData {
                usrname = GlobalVars.clockSettings?.clock_user,
                passwd = GlobalVars.clockSettings?.clock_pass,
                accpriv = GlobalVars.ClockStartPriv
            };
        }

        /// <summary>
        /// Ejecuta todos los procesos de sincronización y actualización del formulario.
        /// </summary>
        private async Task<bool> SyncAll()
        {
            CommonProcs.SetOfflineMode();
            bool upload_result;
            //ToggleConnIndicator(!GlobalVars.BeOffline);

            try {
                await TakeMyTime();
                upload_result = await UploadPunches();
                await GetNotices();
                upload_result = await GetFMDs();
                await ConsolidateHistory();
                await UpdateHistoryPanel();

                if (upload_result && !GlobalVars.BeOffline) RegAccess.SaveLastSync(GetRemoteDateTime());
            } catch(Exception ex) {
                SyncError = "Ocurrió un error no especificado durante la sincronización. Favor de contactar al administrador del sistema. " + ex.Message;
                HideLoader();
                upload_result = false;
            }

            if (ScheduleTriggered && upload_result) {
                LastSyncDate = GetRemoteDateTime();
                ScheduleTriggered = false;
                log.Info("Sincronización programada finalizada correctamente!");
            } else if(RetryingSync && upload_result) {
                log.Info("Intento de Sincronización finalizada correctamente!");
                RetryingSync = false;
            }
            return upload_result;
        }

        private DateTime GetRemoteDateTime() => CurrentRemoteTime.CurrentTime;

        /// <summary>
        /// Registra la marca de tiempo actual del cliente en el servidor.
        /// </summary>
        private async Task TakeMyTime()
        {
            try {
                ScantRequest scantreq = new() {
                    Question = (
                        GlobalVars.clockSettings?.clock_uuid ?? Guid.Empty.ToString() + "|" +
                        GlobalVars.clockSettings?.clock_office.ToString() + "|" +
                        GetRemoteDateTime().ToString("yyyy/MM/ddTHH:mm:ss")
                    )
                };

                ScantResponse response = await CommonProcs.SyncWatchesAsync(scantreq);
            } catch {
                return;
            }
        }

        /// <summary>
        /// Recupera las huellas dactilares de los empleados asignados a la oficina actual.
        /// </summary>
        private async Task<bool> GetFMDs()
        {
            DataTable emp_dt = new();
            int el_idx = 0;
            las_fmds = null;
            fmd_collection = null;
            las_fmds = new List<Fmd>();
            fmd_collection = new List<FMDItem>();

            if (!GlobalVars.BeOffline)
            {
                emp_dt = await CommonProcs.GetOfficeFMDsAsync(new ScantRequest { Question = GlobalVars.clockSettings?.clock_office.ToString() });

                if (emp_dt == null)
                {
                    emp_dt = VoidFMDs;
                } else {
                    await GlobalVars.AppCache.SaveEmployeesAsync(emp_dt);
                }
            } else {
                emp_dt = GlobalVars.AppCache.RetrieveEmployees();
            }

            foreach (DataRow dr in emp_dt.Rows)
            {
                las_fmds.Add(new Fmd(SimpleAES.ToHexBytes(dr["FingerFMD"].ToString()!), GlobalVars.FMDFormat, GlobalVars.FMDVersion));

                var item = new FMDItem {
                    idx = el_idx,
                    offid = int.Parse(dr["OffID"].ToString() ?? "0"),
                    empid = int.Parse(dr["EmpID"].ToString() ?? "0"),
                    fingid = int.Parse(dr["FingerID"].ToString() ?? "0"),
                    empnum = dr["EmpNum"].ToString(),
                    empnom = dr["EmpName"].ToString(),
                    emppass = dr["EmpPass"].ToString(),
                    fmd = SimpleAES.ToHexBytes(dr["FingerFMD"].ToString()!)
                };

                fmd_collection.Add(item);
                FingerPrints.Add(item);

                el_idx++;
            }

            if (las_fmds.Count <= 0) las_fmds.Add(new Fmd(new byte[124], GlobalVars.FMDFormat, GlobalVars.FMDVersion));

            if (((emp_dt == null) || (emp_dt.Rows.Count <= 0)) && GlobalVars.StartingUp)
            {
                SyncError = "No se han encontrado colaboradores asignados a la oficina actualmente configurada.";

                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Recupera los últimos registros de asistencia por empleado, efectuados en la oficina actual.
        /// </summary>
        private async Task GetRecentPunches()
        {
            if (!GlobalVars.BeOffline) {
                emp_punches = await CommonProcs.GetLastPunchesAsync(new ScantRequest { Question = GlobalVars.clockSettings.clock_office.ToString() });

                if (emp_punches == null) {
                    emp_punches = VoidPunches;
                } else {
                    await GlobalVars.AppCache.SaveHistory(emp_punches);
                }
            } else {
                emp_punches = GlobalVars.AppCache.RetrieveHistory();
            }
        }

        /// <summary>
        /// Recupera los avisos emitidos para la oficina actual.
        /// </summary>
        private async Task GetNotices()
        {
            List<NoticeData>? la_salida = new();

            try {
                if (!GlobalVars.BeOffline)
                {
                    var ScantRequest = new ScantRequest { 
                        Question = (GlobalVars.clockSettings.clock_office.ToString()) 
                    };

                    var result = await CommonProcs.GetOfficeNoticesAsync(ScantRequest);
                    List<NoticeData> my_nots = result;

                    if (my_nots != null)
                    {
                        foreach (NoticeData notice in my_nots)
                        {
                            notice.nottit = CommonProcs.Base64ToStr(notice.nottit);
                            notice.notmsg = CommonProcs.Base64ToStr(notice.notmsg);

                            la_salida.Add(notice);
                            Notices.Add(new Notice() {
                                id = notice.notid,
                                caption = notice.nottit,
                                body = notice.notmsg,
                                image = notice.notimg
                            });
                        }

                        await GlobalVars.AppCache.SaveNotices(la_salida);
                    }
                } else {
                    la_salida = GlobalVars.AppCache.RetrieveNotices();
                }

                if (la_salida.Count < 1) la_salida.Add(def_not);
            } catch {
                la_salida = new List<NoticeData> {
                    def_not
                };
            }
            finally {
               notices = la_salida;
            }

            ParseNotice();
        }

        private async void AddNewNotice(Notice? notice)
        {
            await GetNotices();
        }
        /// <summary>
        /// Agrega un aviso al recuperar el registro en tiempo real desde el servidor de WebSocket
        /// </summary>
        public async Task SetNotice(NoticeData notice)
        {
            //tmrNotices.Stop();
            //tmrNotices.Enabled = false;
            //pnlNotBody.Controls.Clear();

            await GetNotices();
            //tmrNotices.Enabled = true;
            curr_not = 0;
            //List<NoticeData> initial;
            //initial = las_notices;
            //las_notices.Add(notice);
        }

        private void GetOffice()
        {
            Office = (GlobalVars.this_office?.Offname + ".");
        }

        private void SetLogo()
        {
            var logo = GlobalVars.mainSettings?.Logo ?? "";
            if (!string.IsNullOrEmpty(logo)) { 
                LogoImage = ImageHelper.LoadFromResource(logo);
            } else {
                LogoImage = ImageHelper.LoadFromAvares("/Assets/DefaultLogo.png");
            }
        }

        /// <summary>
        /// Inicializa el lector de huella dactilar y lo prepara para la captura.
        /// </summary>
        private void StartReader()
        {
            try {
                UrUClass.LoadCurrentReader();

                if (!UrUClass.OpenReader()) {
                    //KillMe("No se pudo inicializar el Lector de Huellas.");
                }

                if (!UrUClass.StartCaptureAsync(OnCaptured))
                {
                    //KillMe("El manejador de evento del Lector de Huella no se puedo asociar.");
                }
            } catch(Exception ex) {
                Dispatcher.UIThread.InvokeAsync(async () => {
                    await Show(null, "Lector no encontrado", "No se ha encontrado ningún lector de huella dactilar o no se ha podido tener acceso al mismo.\n\nPruebe una de las siguientes opciones:\n\n1. Rectifique que el lector se encuentra debidamente conectado al equipo; deberá ver una luz azul en el lector que así lo indica.\n2. Asegúrese que los controladores necesarios han sido correctamente instalados.\n3. Conecte y desconecte el lector o conéctelo a un puerto USB diferente.\n4. Reinicie el equipo.\n\nSi el problema persiste, póngase en contacto con el administrador del sistema.\n\nLa aplicación terminará ahora.", MessageBoxButtons.Ok);
                    KillMe("Error general del Lector de Huellas ==> " + ex.Message);
                });
            }
        }
        #endregion

        #region Registros de asistencia
        private async void PunchIt(int found_inx)
        {
            FoundIndex = PwdPunchIndex;
            await Dispatcher.UIThread.InvokeAsync(PunchRegister);
            PwdPunchIndex = -2;
        }

        private async void ShowEventsByEmployee(int selected_inx)
        {
            if (AttsList.Count > 0 && selected_inx != -1) {
                var employee = AttsList[selected_inx];
                var empData = fmd_collection?.Where(x => x.empid == employee.EmpID).First();

                EmpPunches.Clear();

                await Task.Delay(500);
                await UpdateInfoLabels(6, empData.empnum, employee.FullName);
                DataTable dt_punches = await GetEmpPunches(employee.EmpID);

                foreach (DataRow dr in dt_punches.Rows) {
                    DateTime dattim = CommonProcs.FromFileString(dr["PuncTime"].ToString());
                    int.TryParse(dr["EvID"].ToString(), out int el_ev);

                    var data = new EmployeePunch() {
                        punchdate = CommonProcs.UpperFirst(dattim.ToString("dddd dd/MM/yyyy")),
                        punchtime = dattim.ToString("HH:mm:ss"),
                        punchevent = EvTypes[int.Parse(dr["EvID"].ToString() ?? "0")]
                    };

                    EmpPunches.Add(data);
                }
            }
        }

        private async Task PunchRegister()
        {
            try {
                ToggleTimers(false); //Detiene los temporizadores para calcular el tiempo exacto hasta finalizar el registro

                DateTime this_time = GetRemoteDateTime();
                TimeSpan run_time = GlobalVars.RunningTime.Elapsed;
                DateTime calc_time = GlobalVars.StartTime.Add(run_time);

                await UpdateInfoLabels(4); //Leyenda procesando
                SearchText = "";

                // Si la huella es valida
                if (FoundIndex > -1) // elid_idx
                {
                    FMDItem? emp_finger = fmd_collection?.ElementAt(FoundIndex); //Busca en el listado de huellas de los colaboradores de acuerdo al indice resultante
                    DataTable dt_punches = await GetEmpPunches(emp_finger.empid);

                    int next_ev = 0;
                    //Si el empleado no tiene registros entonces es una entrada
                    if (dt_punches.Rows.Count <= 0) {
                        next_ev = 1;
                    } else {
                        //Si el empleado tiene registros calcula si es entrada o salida
                        PunchLine last_punch = GetLastPunch(dt_punches);
                        next_ev = await ComputeNextEvent(last_punch, this_time);
                    }

                    //Si el registro esta duplicado
                    if (next_ev == -1)
                    {
                        PlayBeep(4);
                        await UpdateInfoLabels(2);
                        ToggleTimers(true); //Reanuda los temporizadores

                        return;
                    }
                    EmpPunches.Clear(); //Limpia el historial de registros del ultimo colaborador

                    PlayBeep(next_ev);

                    PunchLine new_punch = new() {
                        Punchemp = emp_finger.empid,
                        Punchevent = next_ev,
                        Punchtime = this_time,
                        Punchinternaltime = calc_time
                    };

                    RegisterNewPunch(new_punch, emp_finger);
                    // Muestra los registros de entrada y salida del colaborador actual(DataGridView central)
                    foreach (DataRow dr in dt_punches.Rows)
                    {
                        DateTime dattim = CommonProcs.FromFileString(dr["PuncTime"].ToString());
                        int.TryParse(dr["EvID"].ToString(), out int el_ev);

                        var data = new EmployeePunch() {
                            punchdate = CommonProcs.UpperFirst(dattim.ToString("dddd dd/MM/yyyy")),
                            punchtime = dattim.ToString("HH:mm:ss"),
                            punchevent = EvTypes[int.Parse(dr["EvID"].ToString() ?? "0")]
                        };

                        EmpPunches.Add(data);
                    }

                    await UpdateInfoLabels(1, emp_finger.empnum, emp_finger.empnom, new_punch);
                    //Agrega el nuevo evento del colaborador
                    EmpPunches.Add(new EmployeePunch() {
                        punchdate = CommonProcs.UpperFirst(new_punch.Punchtime.ToString("dddd dd/MM/yyyy")),
                        punchtime = new_punch.Punchtime.ToString("HH:mm:ss"),
                        punchevent = EvTypes[new_punch.Punchevent]
                    });

                    //Muestra el evento registrado del colaborador en el DataGridView de la izquierda
                    //OLD: _sourceList.Add(...)
                    var emp_data = new Employee(
                        emp_finger.empid,
                        emp_finger.empnom,
                        new_punch.Punchtime.ToString("dd/MM/yyyy HH:mm"),
                        EvTypes[new_punch.Punchevent]
                    );

                    if(!IsDuplicated(emp_data)) {
                        AttsList.Add(emp_data);
                    }

                    SelectedIndex = AttsList.Count - 1;
                    SelectedItem = 0;
                    LastEmployeeEventItem = EmpPunches.Count - 1;
                } else {
                    EmpPunches.Clear();
                    PlayBeep(3);
                    await UpdateInfoLabels(3);
                }
                ToggleTimers(true); //Reanuda el temporizador esperando otro registro de asistencia.
            } catch (Exception exc) {
                ToggleTimers(true);
                await ShowMessage("Error al procesar la huella", exc.Message);
            }
        }

        /// <summary>
        /// Obtiene el historial de registros de asistencia del colaborador detectado, en el listado de checadas de todos los empleados en una oficina almacenados en memoria.
        /// </summary>
        /// <param name="emp_id"></param>
        /// <returns></returns>
        private async Task<DataTable> OfflineEmpPunches(int emp_id)
        {
            DateTime el_timestamp;
            DataTable dt = VoidPunches;

            try {
                await Task.Run(() =>  {
                    foreach (DataRow dr in emp_punches.Rows)
                    {
                        int el_emp = int.Parse(dr["EmpID"].ToString() ?? "0");

                        if (el_emp == emp_id) {
                            el_timestamp = Convert.ToDateTime(dr["PuncTime"].ToString());

                            dt.Rows.Add(el_emp, dr["EvID"], el_timestamp.ToString("yyyyMMddHHmmss"));
                        }
                    }
                });

                DataView dv = new(dt, "", "PuncTime DESC", DataViewRowState.CurrentRows);
                DataTable dt1 = dv.ToTable().AsEnumerable().Take(10).CopyToDataTable();
                DataView dv2 = new(dt1, "", "PuncTime ASC", DataViewRowState.CurrentRows);

                return dv2.ToTable();
            } catch {}
            return dt;
        }

        /// <summary>
        /// Obtiene el historial de registros de asistencia del colaborador directamente de la BD.
        /// </summary>
        /// <returns></returns>
        private async static Task<DataTable> OnlineEmpPunches(int emp_id)
        {
            DataTable dt = VoidPunches;

            try {
                DataTable DBEmpPunches = await CommonProcs.GetLastPunchesAsync(new ScantRequest { Question = GlobalVars.clockSettings.clock_office.ToString() }, emp_id);

                foreach (DataRow dr in DBEmpPunches.Rows)
                {
                    DateTime el_timestamp = Convert.ToDateTime(dr["PuncTime"].ToString());
                    dt.Rows.Add(emp_id, dr["EvID"], el_timestamp.ToString("yyyyMMddHHmmss"));
                }
            } catch { }

            return dt;
        }

        /// <summary>
        /// Obtiene el historial de registros de asistencia del colaborador detectado.
        /// </summary>
        /// <param name="emp_id">ID del colaborador.</param>
        /// <returns>DataTable con el histórico de registros del colaborador.</returns>
        private async Task<DataTable> GetEmpPunches(int emp_id, bool be_offline = true)
        {
            DataTable dt = VoidPunches;
            try {
                dt = GlobalVars.BeOffline ? await OfflineEmpPunches(emp_id) : await OnlineEmpPunches(emp_id);
            } catch {}

            return dt;
        }

        /// <summary>
        /// Crea un objeto con la información del último registro de asistencia del historial del colaborador detectado.
        /// </summary>
        /// <param name="emp_pncs">DataTable con el histórico de los registros de asistencias del colaborador.</param>
        /// <returns>Objeto PunchLine que encapsula la información del último registro de asistencia encontrado.</returns>
        private static PunchLine GetLastPunch(DataTable emp_pncs)
        {
            DataRow dr = emp_pncs.Rows[^1];

            return new PunchLine {
                Punchemp = int.Parse(dr["EmpID"].ToString() ?? "0"),
                Punchevent = int.Parse(dr["EvID"].ToString() ?? "0"),
                Punchtime = CommonProcs.FromFileString(dr["PuncTime"].ToString())
            };
        }

        /// <summary>
        /// Calcula el siguiente tipo de evento basado en el último evento registrado y los parámetros definidos en la configuración del sistema.
        /// </summary>
        /// <param name="last_punch">Objeto con la información del último registro de asistencia.</param>
        /// <param name="new_punch">Momento del nuevo evento de asistencia.</param>
        /// <returns>El valor del elemento del arreglo EvTypes correspondiente al siguiente evento calculado.</returns>
        private static async Task<int> ComputeNextEvent(PunchLine last_punch, DateTime new_punch)
        {
            TimeSpan ev_diff = new_punch.Subtract(last_punch.Punchtime);
            //Valida si ya cumplio el tiempo estipulado para no considerarlo como duplicado
            if (ev_diff.TotalSeconds < CommonProcs.ParamInt(3)) {
                return -1;
            }

            try {
                switch (last_punch.Punchevent)
                {
                    case 2: //Si es salida
                        //Podria presentarse el caso de que marque "Entrada" cuando sea "Salida" debido a un fallo de sincronizacion de datos
                        //Normalmente la salida es a las 5:05, entonces validamos si la hora actual es mayor o igual a las 5.
                        int _evt = 1;

                        if (new_punch.Hour >= 17) {
                            _evt = -1;

                            var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
                            var windows = MainWindow?.OwnedWindows;
                            if (MainWindow is { } mainWindow && windows.Count == 0) {
                                var dialog = new EventPromptWindow() {
                                    DataContext = new EventPromptViewModel(TimeSpan.Zero)
                                };
                                _evt = await dialog.ShowDialog<int>(mainWindow);
                            }
                        }

                        return _evt; //Entonces es entrada

                    case 1: //Si es entrada
                        TimeSpan max_shift = CommonProcs.ParamTSpan(12);
                        //En caso que hayas registrado entrada pero no salida. Ya paso mas tiempo de lo permitido.

                        if (ev_diff > max_shift) {
                            int evt = -1;

                            var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
                            var windows = MainWindow?.OwnedWindows;
                            if (MainWindow is { } mainWindow && windows.Count == 0) {
                                var dialog = new EventPromptWindow() {
                                    DataContext = new EventPromptViewModel(max_shift)
                                };
                                evt = await dialog.ShowDialog<int>(mainWindow);
                            }

                            return evt;
                        } else {
                            return 2; //Devuelve salida
                        }

                    case 0:
                        return 0;

                    default:
                        return 0;
                }
            } catch {
                return 0;
            }
        }

        /// <summary>
        /// Almacena el nuevo registro de asistencia en memoria. Además, si el cliente Checador esta conectado al servidor WebSocket, registra en tiempo real el evento indicado en la BD, en caso contrario, lo guarda en caché, en espera de su sincronización.
        /// </summary>
        /// <param name="new_punch">Objeto con la información del nuevo registro de asistencia.</param>
        private void RegisterNewPunch(PunchLine new_punch, FMDItem? emp = null)
        {
            log.Info("El empleado "+ emp.empnom +" ha registrado " + EvTypes[new_punch.Punchevent] + " a las " + new_punch.Punchtime.ToString("HH:mm:ss") + " horas.");

            emp_punches.Rows.Add(new_punch.Punchemp.ToString(), new_punch.Punchevent.ToString(), new_punch.Punchtime.ToString("yyyy/MM/dd HH:mm:ss"), new_punch.Punchinternaltime.ToString("yyyy/MM/dd HH:mm:ss"));
            GlobalVars.AppCache.StorePunch(new_punch);

            if (IsNetConnected) {
                _WSClient.StorePunch(new_punch, emp);
            }
        }

        /// <summary>
        /// Envía los registros de asistencia almacenados en caché al servidor.
        /// </summary>
        private Task<bool> UploadPunches()
        {
            tmrSyncRetry.IsEnabled = false;

            if (!GlobalVars.BeOffline) {
                try {
                    string[] from_file = GlobalVars.AppCache.GetCachedPunches(2);

                    if (from_file.Length > 0) {
                        ScantRequest la_req = new() {
                            Question = (
                                GlobalVars.clockSettings.clock_office.ToString() + "." +
                                CommonProcs.ZipString(string.Join(GlobalVars.SeparAtor[0].ToString(), from_file))
                            )
                        };

                        if (CommonProcs.SendPunches(la_req)) {
                            GlobalVars.AppCache.PurgeCachedPunches(2);
                            log.Info($"Se sincronizaron correctamente {from_file.Length} registro(s) de empleados.");



                            return Task.FromResult(true);
                        } else {
                            SyncError = "El servidor ha reportado un problema al procesar los registros de asistencia. Favor de comunicarse con el administrador del sistema.";
                            log.Warn("El servidor ha reportado un problema al procesar los registros de asistencia.");
                            tmrSyncRetry.IsEnabled = true;

                            return Task.FromResult(false);
                        }
                    }
                    else {
                        return Task.FromResult(true);
                    }
                } catch (Exception exc) {
                    SyncError = "Ha ocurrido un fallo al sincronizar los registros de asistencia. Favor de comunicarse con el administrador del sistema.";
                    tmrSyncRetry.IsEnabled = true;
                    log.Error(exc, SyncError);

                    return Task.FromResult(false);
                }
            } else {
                tmrSyncRetry.IsEnabled = true;
                return Task.FromResult(true);
            }
        }
        #endregion

        #region Avisos

        /// <summary>
        /// Muestra la información del anuncio correspondiente al índice actual.
        /// </summary>
        private void ParseNotice()
        {
            try
            {
                NoticeData la_notice = notices[curr_not];
                bool has_text = !(string.IsNullOrWhiteSpace(la_notice.notmsg) || (la_notice.notmsg == "null"));
                bool has_image = !(string.IsNullOrWhiteSpace(la_notice.notimg) || (la_notice.notimg == "null"));

                //pnlNotBody.Controls.Clear();

                if (has_image) {
                    NoticeImage = CommonProcs.Base64ToBitmap(la_notice.notimg ?? "");
                }

                if (has_text)
                {
                    NoticeBody = la_notice.notmsg ?? "";
                }

                NoticeTitle = la_notice.nottit ?? "";
                SetNextNotice();
                if (NoticeCollectionEmpty) tmrNotices.Stop();
            }
            catch (Exception ex)
            {
                log.Warn("Error while showing Notice: " + ex.Message);
            }
        }

        /// <summary>
        /// Establece el siguiente índice del ciclo de avisos.
        /// </summary>
        private static void SetNextNotice()
        {
            curr_not = ((curr_not + 1) >= notices.Count) ? 0 : (curr_not + 1);
        }
        #endregion

        #region Acciones del formulario
        /// <summary>
        /// Configura el reloj y su temporizador.
        /// </summary>
        private async Task SetClock()
        {
            var data = await GetTimeNow();
            CurrentRemoteTime = data;
            CurrentTime = data.TimeString!;
            CurrentLongDate = TodayLongDate;

            StartClock();
        }

        private void StartClock()
        {
            //new DispatcherTimer(TimeSpan.FromSeconds(1), DispatcherPriority.Normal, TimerTick).Start();
            tmrCachedTime.Interval = TimeSpan.FromSeconds(1);
            tmrCachedTime.Tick += TmrCachedTime_Tick;
            tmrCachedTime.Start();

            tmrClock.Interval = TimeSpan.FromSeconds(1);
            tmrClock.Tick += ParseTick;
            tmrClock.Start();
        }

        private async void TmrCachedTime_Tick(object? sender, EventArgs e)
        {
            // Obtener la hora del servidor NTP solo si no hay una hora en caché
            //if (GlobalVars.CachedTime == DateTime.MinValue) {
                var data = await GetTimeNow();
                GlobalVars.CachedTime = data.CurrentTime;
            //} else {
                // Calcular la siguiente hora sumando un segundo
            //    GlobalVars.CachedTime = GlobalVars.CachedTime.AddSeconds(1);
            //}

            // Mostrar o usar cachedTime en tu aplicación
            //Debug.WriteLine("Hora calculada: " + GlobalVars.CachedTime);
        }

        /// <summary>
        /// Inicia o detiene los temporizadores.
        /// </summary>
        /// <param name="startstop">True para iniciar los temporaizadores, False para detenerlos.</param>
        private void ToggleTimers(bool startstop = true)
        {
            tmrNotices.IsEnabled = startstop;
            tmrClock.IsEnabled = startstop;
        }

        /// <summary>
        /// Termina la aplicación.
        /// </summary>
        private void KillMe(string reason = "")
        {
            forceexit = true;
            GlobalVars.ForceExit = forceexit;
            log.Info("Se ha forzado el cierre de la aplicación." + (reason != "" ? (" " + reason): ""));
            Dispatcher.UIThread.InvokeAsync(async () => {
                await new MainWindow().LogOut(forceexit);
            });
        }

        /// <summary>
        /// Abre el cuadro de diálogo de Sincronización Manual.
        /// </summary>
        private void InvokeManualSyncEvt(bool sync = true)
        {
            Dispatcher.UIThread.InvokeAsync(async() => {
                await InvokeManualSync();
                KillMe("Sincronización manual de eventos activado.");
            });
        }

        private async Task InvokeManualSync()
        {
            if (CommonValids.InvokeLogin(GlobalVars.ClockSyncPriv)) {
                await SyncWithLoader();
                //await Task.Delay(2000);
                GlobalVars.ForceExit = true;
            }
        }

        /// <summary>
        /// Evalúa la operación a ejecutar cada vez que se actualiza el reloj.
        /// </summary>
        private void ParseTick(object? sender, EventArgs e)
        {
            if (CheckSyncDTime()) {
                ScheduleTriggered = true;
                Dispatcher.UIThread.InvokeAsync(async () => {
                    await SyncWithLoader();
                    await SendEmployeesWithNoCheckInOut();
                });
            }

            Dispatcher.UIThread.InvokeAsync(() => {
                CurrentRemoteTime = new RemoteTime {
                    CurrentTime = GlobalVars.CachedTime,
                    TimeString = GlobalVars.CachedTime.ToString("HH:mm:ss")
                };

                CurrentTime = CurrentRemoteTime.TimeString;
            });

            CurrentLongDate = TodayLongDate; //IMPORTANTE! YA QUE SI LA APP NO SE CIERRA SIEMPRE MOSTRARA LA ULTIMA FECHA DE EJECUCION DE LA APP
            ShowWebSocketStatus();
            IsPusherConnected = WSClient.IsPusherConnected();
        }

        private async Task SendEmployeesWithNoCheckInOut()
        {
            var off_id = GlobalVars.this_office?.Offid ?? 0;

            DataTable dt = await DBMethods.GetEmployeesWithNoCheckInOut(off_id);
            var body = EmailSenderHandler.BuildMessage(dt);

            if (dt.Rows.Count > 0 && dt.Columns.Contains("ERROR") && dt.Rows[0]["ERROR"].ToString() != "None") {
                return;
            }

            if(dt.Rows.Count <= 0) {
                return;
            }

            await Task.Run(async () => {
                await EmailSenderHandler.SendEmailAsync("Control de Asistencia " + GetRemoteDateTime().ToString("dd/MM/yyyy") , body);
            });
        }

        private void ShowWebSocketStatus()
        {
            try {
                if (!m_settings.Websocket_enabled) {
                    //lblSpacer.ForeColor = System.Drawing.Color.BlueViolet;
                    Status = "Servidor WebSocket desactivado";
                } else if (_WSClient != null && WSClient.IsPusherConnected()) {
                    //lblSpacer.ForeColor = System.Drawing.SystemColors.MenuHighlight;
                    Status = "Servidor WebSocket en línea";
                } else {
                    //lblSpacer.ForeColor = System.Drawing.Color.Red;
                    Status = "Servidor WebSocket desconectado";
                }
            } catch(Exception ex) {
                log.Error(new Exception(), "Error while connecting with WebSocket server: " + ex.ToString());
            }
        }

        /// <summary>
        /// Evento TICK del temporizador de los avisos.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TmrNotices_Tick(object? sender, EventArgs e)
        {
            ParseNotice();
        }

        /// <summary>
        /// Evento TICK del temporizador del reintento de sincronización.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TmrSyncRetry_Tick(object? sender, EventArgs e)
        {
            if(!ScheduleTriggered) {
                RetryingSync = true;
                Dispatcher.UIThread.InvokeAsync(async () => await SyncWithLoader());
            }
        }

        /// <summary>
        /// Evalúa si es hora de iniciar la sincronización automática, según los parámetros de configuración del sistema.
        /// </summary>
        /// <returns>True si la hora actual coincide con la configurada en el párametro correspondiente.</returns>
        private bool CheckSyncDTime()
        {
            DateTime sync_sched = CommonProcs.ParamDTime(2);
            var remote = CurrentRemoteTime.CurrentTime;

            return remote.Date > LastSyncDate.Date && remote.Hour == sync_sched.Hour && (remote.Minute == sync_sched.Minute) && !RetryingSync;
        }

        /// <summary>
        /// Inicia la sincronización del formulario, mostrando el cuadro de carga.
        /// </summary>
        /// <param name="el_msg">Texto (opcional) que sobreescribirá el mensaje predeterminado de la ventana de carga.</param>
        private async Task<bool> SyncWithLoader()
        {
            ToggleTimers(false);

            var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
            string mssg = "Sincronizando, por favor espere...";
            var _window = new LoaderWindow() {
                DataContext = new LoaderViewModel(mssg)
            };

            if (MainWindow.Name == "wdw_Main") {
               _ = _window.ShowDialog(MainWindow);
            }

            IsSyncing = true;
            bool sync_resp = await SyncAll();
            IsSyncing = false;

            if (!sync_resp) await ShowMessage("Problema al sincronizar", SyncError, -1, 150);
            HideLoader();

            ToggleTimers(true);

            return sync_resp;
        }

        private void HideLoader() { 
            var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
            var windows = MainWindow?.OwnedWindows;
            var LoaderWindow = windows?.Where(x => x.Name == "xLoaderWindow").FirstOrDefault();

            if ((MainWindow.Name == "wdw_Main") && windows.Count > 0 && LoaderWindow != null && !IsSyncing)
            {
                foreach (var window in windows) {
                    window.Close();
                }
            }
        }

        /// <summary>
        /// Muestra el cuadro de carga asincrónicamente.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void BgwLoader_DoWork(object? sender, DoWorkEventArgs e)
        {
            string? el_msg = (string?)e.Argument;

            //Dispatcher.UIThread.InvokeAsync(async () => {
            //    var _window = new LoaderWindow() {
            //        DataContext = new LoaderViewModel(el_msg)
            //    };

            //    if ((Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow is { } mainWindow) {
            //        await _window.ShowDialog(mainWindow);
            //    }
            //});
        }

        /// <summary>
        /// Carga y reproduce el sonido indicado, de acuerdo al tipo de evento, como retroalimentación del registro de asistencia.
        /// </summary>
        /// <param name="beep_type">Sonido que será reproducido.</param>
        /// <param name="failsafe">Indica si debe omitir el intento de cargar el sonido desde un archivo externo para evitar errores.</param>
        public void PlayBeep(int beep_type = 0, bool failsafe = false)
        {
            //var assets = AvaloniaLocator.Current.GetService<Avalonia.Platform.IAssetLoader>();
            //string? assemblyName = Assembly.GetExecutingAssembly().GetName().Name;

            //var resourcesNames = Assembly.GetExecutingAssembly().GetManifestResourceNames(); // ["!AvaloniaResources"]
            //var pathAvaresRessources = new Uri($"avares://{resourcesNames[0].Replace("!", "")}/Assets");
            //var pathAvaresProject = new Uri($"avares://{assemblyName}/Assets");
            //var averesRessources = assets.GetAssets(pathAvaresProject, null);

            if ((beep_type < 0) || (beep_type >= PunchSounds.Length)) failsafe = true;

            if (failsafe) {
                //DEPRECATED: JUST FOR INFORMATION OF FIRST VERSION
                try {
                    Stream? str = null;

                    switch (beep_type) {
                        case 4:
                           //str = Properties.Resources.PunchError;
                           break;

                        case 3:
                           break;

                        case 2:
                           break;

                        case 1:
                           break;

                        case 0:
                           break;

                        default:
                           break;
                    }

                    // Crear una nueva instancia de WaveOutEvent y reproduce el archivo de audio
                    waveOutEvent = new WaveOutEvent();
                    waveOutEvent.Init(new WaveFileReader(str));
                    waveOutEvent.Play();
                } catch {
                    StopSound();
                    return;
                }
            } else {
                string? beep_file = GlobalVars.AppWorkPath + "Assets\\Audio\\Punch" + PunchSounds[beep_type] + ".wav";

                try {
                    StopSound();

                    // Crear una nueva instancia de WaveOutEvent y reproducir el archivo de audio
                    waveOutEvent = new WaveOutEvent();
                    waveOutEvent.Init(new WaveFileReader(beep_file));
                    waveOutEvent.Play();
                } catch {
                    PlayBeep(beep_type, true);
                    return;
                }
            }
        }

        /// <summary>
        /// Detener la reproducción actual si ya se está reproduciendo
        /// </summary>
        private void StopSound()
        {
            if (waveOutEvent != null) {
                waveOutEvent.Stop();
                waveOutEvent.Dispose();
            }
        }

        /// <summary>
        /// Llena el panel del histórico de registros de asistencia con las que fueron encontradas para el día actual.
        /// </summary>
        private async Task UpdateHistoryPanel()
        {
            int emp_idx = -1;
            string? emp_name = string.Empty;

            DateTime today = GetRemoteDateTime();

            var filteredRows = emp_punches?.AsEnumerable()
            .Where(p => Convert.ToDateTime(p["PuncTime"].ToString()) >= new DateTime(today.Year, today.Month, today.Day, 0, 0, 0))
            .GroupBy(row => new { 
                EmpID = row.Field<int>("EmpID"), 
                EvID = row.Field<int>("EvID"),
                PuncTime = row.Field<string>("PuncTime")
            })
            .Select(group => group.First())
            .OrderBy(x => x.Field<int>("EmpID"))
            //.Take(40)
            .ToList();

            if (filteredRows != null && filteredRows.Any())
            {
                try {
                    // Copy the filtered rows to a new DataTable and sort by "PuncTime"
                    DataTable dt = new DataView(filteredRows.CopyToDataTable(), "", "PuncTime ASC", DataViewRowState.CurrentRows).ToTable();

                    AttsList.Clear();
                    EmpPunches.Clear();
                    Employee.ResetAndReloadData();

                    foreach (DataRow dr in dt.Rows) {
                        emp_idx = fmd_collection.FindIndex(e => e.empid == dr.Field<int>("EmpID"));
                        emp_name = (emp_idx > -1) ? fmd_collection.ElementAt(emp_idx)?.empnom : string.Empty;

                        if (!string.IsNullOrWhiteSpace(emp_name)) {
                            DateTime.TryParse(dr["PuncTime"].ToString(), out DateTime PuncTime);

                            //OLD: _sourceList.Add(...)
                            AttsList.Add(new Employee(
                               dr.Field<int>("EmpID"),
                               emp_name,
                               PuncTime.ToString("dd/MM/yyyy HH:mm"),
                               EvTypes[dr.Field<int>("EvID")]
                            ));
                        }
                    }

                    SelectedIndex = AttsList.Count - 1;//_sourceList.Count - 1;
                    SelectedItem = 0;
                } catch (Exception ex) {
                    log.Error(new Exception(), "Error al llenar el panel del histórico de registros de asistencia: " + ex);
                }
            }

            await UpdateInfoLabels(5);
        }

        /// <summary>
        /// Consolida los registros de asistencia almacenados en caché con los recuperados del histórico, para poblar el panel histórico de la aplicación.
        /// </summary>
        private async Task ConsolidateHistory()
        {
            await GetRecentPunches();
            string[] cached_punches = GlobalVars.AppCache.GetCachedPunches(2);
            string[] punch_parts;

            foreach (string str in cached_punches)
            {
                punch_parts = str.Split(new char[] { '|' });

                int EmpID = int.Parse(punch_parts[0]);
                int EvID = int.Parse(punch_parts[1]);
                string? PuncTime = (punch_parts.Length > 2) ? CommonProcs.ParseValidDT(punch_parts[2], "yyyy/MM/dd HH:mm:ss") : null;
                string? PuncCalc = (punch_parts.Length > 3) ? CommonProcs.ParseValidDT(punch_parts[3], "yyyy/MM/dd HH:mm:ss") : null;

                //emp_punches.Rows.Add(EmpID, EvID, DateTime.Parse(punch_parts[2]), PuncCalc);
                emp_punches.Rows.Add(EmpID, EvID, PuncTime, PuncCalc);
            }
        }

        /// <summary>
        /// Configura los intervalos para los temporizadores de la aplicación.
        /// </summary>
        private void ConfigTimers()
        {
            int retrymins = CommonProcs.ParamInt(11); //Retry interval in minutes

            retrymins = (retrymins < 10) ? 10 : retrymins;
            tmrSyncRetry.Interval = TimeSpan.FromMilliseconds(retrymins * 60 * 1000);
            tmrSyncRetry.Tick += TmrSyncRetry_Tick;
            tmrSyncRetry.Start();

            tmrNotices.Interval = TimeSpan.FromMilliseconds(CommonProcs.ParamInt(9) * 1000);
            tmrNotices.Tick += TmrNotices_Tick;
            tmrNotices.Start();

            tmrCheckNetConnection.Interval = TimeSpan.FromMilliseconds(5000);
            tmrCheckNetConnection.Tick += async (sender, e) => await ToggleConnIndicator();
            tmrCheckNetConnection.Start();
        }

        private async Task ToggleConnIndicator()
        {
            var IsOnline = await CommonValids.ValidInternetConnAsync();

            NetworkConStatus = IsOnline ? "Conectado" : "Sin conexión";
            IsNetConnected = IsOnline;
            GlobalVars.BeOffline = !IsOnline;
        }
        #endregion

        #region Manejadores de eventos
        /// <summary>
        /// Procesa la huella capturada por el lector.
        /// </summary>
        /// <param name="captureResult">Datos capturados por el lector.</param>
        public void OnCaptured(CaptureResult captureResult)
        {
            IDThreshold = CommonProcs.ParamInt(7) * 1 / CommonProcs.ParamInt(8);

            // Check capture quality and throw an error if bad.
            if (!UrUClass.CheckCaptureResult(captureResult)) return;

            DataResult<Fmd> preIdentify = FeatureExtraction.CreateFmdFromFid(captureResult.Data, Constants.Formats.Fmd.ISO);
            IdentifyResult identified = Comparison.Identify(preIdentify.Data, 0, las_fmds, IDThreshold, 1);

            if (identified.ResultCode == Constants.ResultCode.DP_SUCCESS) {
                elid_idx = (identified.Indexes.Length > 0) ? identified.Indexes[0][0] : -1;
                FoundIndex = elid_idx;
                Dispatcher.UIThread.InvokeAsync(PunchRegister);
                //UrUClass.ControlControls(4, btnParseID);
            } else if (identified.ResultCode == Constants.ResultCode.DP_DEVICE_BUSY) {
                Dispatcher.UIThread.InvokeAsync(async () => {
                    await ShowMessage("El lector no responde", "El lector de huella dactilar está ocupado y no responde en estos momentos. Por favor, espere unos segundos e inténtelo de nuevo");
                });
            } else {
                forceexit = true;
                Dispatcher.UIThread.InvokeAsync(async() => {
                    await ShowMessage("Fallo del lector", "Ha ocurrido un fallo con el lector de huella dactilar o ha dejado de ser reconocido por el sistema.\n\nLa aplicación no puede continuar y se cerrará ahora.", -1, -1, SizeToContent.Height);
                    KillMe("Fallo del Lector dactilar o ha dejado de ser reconocido por el sistema.");
                });
                //UrUClass.ControlControls(3, this);
            }
        }

        /// <summary>
        /// Maximiza la ventana después del evento LOAD.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private async Task FormShown()
        {
            //WindowState = FormWindowState.Maximized;
            await StarterSync();

            if (GlobalVars.SyncOnly) KillMe("Cierre después de sincronizar las checadas en el evento FormShown.");
        }

        /// <summary>
        /// Detiene el lector de huella y libera los recursos tras el cierre del formulario.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CloseReader()
        {
            UrUClass.CancelCaptureAndCloseReader(OnCaptured);
        }
        #endregion

        #region Objetos dinámicos
        private CancellationTokenSource _cancellationTokenSource = new();
        /// <summary>
        /// Actualiza las etiquetas(Leyendas) al procesar la información de eventos.
        /// </summary>
        /// <param name="la_action">La acción a la que se hace referencia.</param>
        /// <param name="emp_num">Número del colaborador.</param>
        /// <param name="emp_nom">Nombre del colaborador.</param>
        /// <param name="la_punch">Objeto que encapsula la información del registro de asistencia.</param>
        private async Task UpdateInfoLabels(int la_action, string? emp_num = null, string? emp_nom = null, PunchLine? la_punch = null)
        {
            string txtlblName;
            string txtlblEvent;

            _cancellationTokenSource.Cancel(); // Cancel any previous delay
            _cancellationTokenSource = new CancellationTokenSource(); // Create a new CancellationTokenSource
            try {
                await Task.Delay(200, _cancellationTokenSource.Token); // Use the new token
            } catch (TaskCanceledException) {
                return; // Exit if the delay was canceled
            }

            switch (la_action)
            {
                case 6: //Solo muestra informacion
                    txtlblName = emp_num + " - " + emp_nom;
                    txtlblEvent = "Esperando huella...";
                    break;
                case 5: //Esperando
                    txtlblName = string.Empty;
                    txtlblEvent = "Esperando huella...";
                    break;

                case 4: //Procesando
                    txtlblName = "Procesando...";
                    txtlblEvent = "Espere...";
                    break;

                case 3: //Huella no encontrada
                    txtlblName = "No se encontró su huella";
                    txtlblEvent = "Por favor, inténtelo de nuevo.";
                    break;

                case 2: //Registro duplicado
                    var allowed_time = CommonProcs.ParamInt(3);
                    string secs_str = (allowed_time == 1) ? "segundo." : (allowed_time + " segundos.");

                    txtlblName = "Registro duplicado";
                    txtlblEvent = "Sólo puede generar un registro cada " + secs_str;
                    break;

                case 1: //Registro correcto
                    try {
                        txtlblName = emp_num + " - " + emp_nom;
                        txtlblEvent = EvTypes[la_punch.Punchevent] + " registrada a las " + la_punch.Punchtime.ToString("HH:mm:ss") + " horas.";
                        break;
                    } catch {
                        await UpdateInfoLabels(0);
                        return;
                    }

                case 0: //Limpia etiquetas
                    txtlblName = string.Empty;
                    txtlblEvent = string.Empty;
                    break;

                default:
                    return;
            }

            EmployeeName = txtlblName;
            EmployeeEvent = txtlblEvent;
        }
        #endregion
    }

    /// <summary>
    /// PageTransitions are used to render a transition between two views, for example in a Carousel or TransitioningContentControl
    /// <para>The duration must be set before the transition is used and must be greater than 0. If not, you will get an error.</para>
    /// </summary>
    public class PageTransition : ViewModelBase
    {
        public PageTransition(string displayTitle)
        {
            DisplayTitle = displayTitle;
        }

        public string DisplayTitle { get; }


        private IPageTransition? _Transition;

        /// <summary>
        /// Gets or sets the transition
        /// </summary>
        public IPageTransition? Transition
        {
            get { return _Transition; }
            set { this.RaiseAndSetIfChanged(ref _Transition, value); }
        }

        public override string ToString()
        {
            return DisplayTitle;
        }

    }

    /// <summary>
    /// You can also create your own PageTransition by implementing the IPageTransition-interface.
    /// </summary>
    public class CustomTransition : IPageTransition
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CustomTransition"/> class.
        /// </summary>
        public CustomTransition()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CustomTransition"/> class.
        /// </summary>
        /// <param name="duration">The duration of the animation.</param>
        public CustomTransition(TimeSpan duration)
        {
            Duration = duration;
        }

        /// <summary>
        /// Gets the duration of the animation.
        /// </summary>
        public TimeSpan Duration { get; set; }

        public async Task Start(Visual? from, Visual? to, bool forward, CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return;
            }

            var tasks = new List<Task>();
            var parent = GetVisualParent(from, to);
            var scaleProperty = ScaleTransform.ScaleYProperty;

            if (from != null)
            {
                var animation = new Animation {
                    FillMode = FillMode.Forward,
                    Children = {
                        new KeyFrame
                        {
                            Setters = { new Setter { Property = scaleProperty, Value = 1d } },
                            Cue = new Cue(0d)
                        },
                        new KeyFrame
                        {
                            Setters =
                            {
                                new Setter
                                {
                                    Property = scaleProperty,
                                    Value = 0d
                                }
                            },
                            Cue = new Cue(1d)
                        }
                    },
                    Duration = Duration
                };
                tasks.Add(animation.RunAsync(from, cancellationToken));
            }

            if (to != null)
            {
                to.IsVisible = true;
                var animation = new Animation {
                    FillMode = FillMode.Forward,
                    Children = {
                        new KeyFrame
                        {
                            Setters =
                            {
                                new Setter
                                {
                                    Property = scaleProperty,
                                    Value = 0d
                                }
                            },
                            Cue = new Cue(0d)
                        },
                        new KeyFrame
                        {
                            Setters = { new Setter { Property = scaleProperty, Value = 1d } },
                            Cue = new Cue(1d)
                        }
                    },
                    Duration = Duration
                };
                tasks.Add(animation.RunAsync(to, cancellationToken));
            }

            await Task.WhenAll(tasks);

            if (from != null && !cancellationToken.IsCancellationRequested)
            {
                from.IsVisible = false;
            }
        }

        /// <summary>
        /// Gets the common visual parent of the two control.
        /// </summary>
        /// <param name="from">The from control.</param>
        /// <param name="to">The to control.</param>
        /// <returns>The common parent.</returns>
        /// <exception cref="ArgumentException">
        /// The two controls do not share a common parent.
        /// </exception>
        /// <remarks>
        /// Any one of the parameters may be null, but not both.
        /// </remarks>
        private static Visual GetVisualParent(Visual? from, Visual? to)
        {
            var p1 = (from ?? to)!.GetVisualParent();
            var p2 = (to ?? from)!.GetVisualParent();

            if (p1 != null && p2 != null && p1 != p2)
            {
                throw new ArgumentException("Controls for PageSlide must have same parent.");
            }

            return (Visual)(p1 ?? throw new InvalidOperationException("Cannot determine visual parent."));
        }
    }

    public class GetMemoryData
    {

    }
}
